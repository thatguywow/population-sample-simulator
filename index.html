<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Population % Simulator — Tank Top Example</title>
<style>
  :root{--bg:#f6f7fb;--card:#fff;--muted:#6b7280;--accent:#0366d6}
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;background:var(--bg);color:#0b1220}
  .wrap{max-width:980px;margin:20px auto;padding:14px}
  .card{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 6px 20px rgba(16,24,40,0.06);margin-bottom:12px}
  h1{margin:0 0 6px 0;font-size:20px}
  label{display:block;margin-top:8px;font-weight:600}
  input,select,textarea{width:100%;padding:10px;margin-top:6px;border-radius:8px;border:1px solid #e6e9ef;box-sizing:border-box}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .col{flex:1;min-width:120px}
  .btn{display:inline-block;padding:10px 14px;border-radius:8px;border:0;background:var(--accent);color:white;cursor:pointer}
  .muted{color:var(--muted);font-size:13px}
  pre{background:#0b1220;color:#e6eef8;padding:12px;border-radius:8px;overflow:auto}
  .small{font-size:13px;color:var(--muted)}
  .results{display:flex;gap:12px;flex-wrap:wrap;margin-top:10px}
  .tile{background:#f8fafc;padding:10px;border-radius:8px;min-width:160px}
  a.link{color:var(--accent)}
  footer{font-size:13px;color:var(--muted);text-align:center;margin-top:8px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Population % Simulator</h1>
    <div class="muted small">Ask "What percentage of X wear Y daily?" — the site uses editable priors + optional evidence to produce estimates and uncertainty.</div>
  </div>

  <div class="card">
    <label>Natural-language question (e.g. "What % of men wear a tank top daily?")</label>
    <input id="question" placeholder='e.g. "What % of men wear a tank top daily?"' />

    <div class="row" style="margin-top:8px">
      <div class="col">
        <label>Detected group (you can edit)</label>
        <input id="group" />
      </div>
      <div class="col">
        <label>Detected behaviour / item (edit)</label>
        <input id="behavior" />
      </div>
      <div class="col">
        <label>Mode</label>
        <select id="mode">
          <option value="estimate">Estimate (use priors)</option>
          <option value="simulate">Simulate population sample</option>
        </select>
      </div>
    </div>

    <div style="margin-top:10px" class="small muted">
      We ship the page with **editable priors** (illustrative). Add your survey evidence below to update the estimate.
    </div>

    <div style="margin-top:12px" class="row">
      <button id="askBtn" class="btn">Get estimate</button>
      <button id="addEvidenceBtn" class="btn" style="background:#10b981">Add evidence (survey)</button>
      <button id="exportBtn" class="btn" style="background:#475569">Export CSV</button>
    </div>
  </div>

  <div class="card">
    <h3>Data & Priors (editable)</h3>
    <div class="muted small">Priors are Beta(alpha,beta)-style counts (interpretable as a prior sample). Edit them to reflect better knowledge.</div>

    <div style="margin-top:8px" class="row">
      <div class="col">
        <label>Group key (examples: male,female,all)</label>
        <input id="priorkey" />
      </div>
      <div class="col">
        <label>Item key (examples: tank_top_daily,hat_daily)</label>
        <input id="priorkey_item" />
      </div>
      <div class="col">
        <label>Alpha (prior successes)</label>
        <input id="priorAlpha" type="number" />
      </div>
      <div class="col">
        <label>Beta (prior failures)</label>
        <input id="priorBeta" type="number" />
      </div>
    </div>

    <div style="margin-top:8px">
      <button id="savePriorBtn" class="btn">Save prior</button>
      <div id="priorsList" style="margin-top:10px"></div>
    </div>
  </div>

  <div class="card">
    <h3>Evidence (surveys you add)</h3>
    <div class="small muted">Add counts from surveys (e.g., "120 of 1000 men reported wearing tank top daily"). These will update the posterior.</div>

    <div class="row" style="margin-top:8px">
      <div class="col">
        <label>Source name</label>
        <input id="evSource" placeholder="e.g., SurveyXYZ 2023" />
      </div>
      <div class="col">
        <label>Group key</label>
        <input id="evGroup" placeholder="male" />
      </div>
      <div class="col">
        <label>Item key</label>
        <input id="evItem" placeholder="tank_top_daily" />
      </div>
      <div class="col">
        <label>Successes (those who wear)</label>
        <input id="evSuccess" type="number" placeholder="e.g. 120" />
      </div>
      <div class="col">
        <label>Trials (sample size)</label>
        <input id="evTrials" type="number" placeholder="e.g. 1000" />
      </div>
    </div>

    <div style="margin-top:8px">
      <button id="saveEvidenceBtn" class="btn">Add evidence</button>
      <div id="evidenceList" style="margin-top:10px"></div>
    </div>
  </div>

  <div class="card">
    <h3>Results</h3>
    <div id="resultSummary" class="muted small">No estimate yet.</div>

    <div class="results" id="resultTiles"></div>

    <div style="margin-top:12px">
      <h4>Posterior samples (first 200)</h4>
      <pre id="posteriorOut">—</pre>
    </div>
  </div>

  <footer>
    <div class="small muted">This is an offline-first estimator. To improve realism: add authoritative surveys as evidence, or replace priors with meta-analytic priors from papers.</div>
  </footer>
</div>

<script>
/* ---------- Core model ---------- */

/*
 Approach:
 - Store priors per (group,item) as Beta(alpha,beta).
 - Evidence is counts (successes, trials) that update posterior: Beta(alpha+succ, beta+(trials-succ))
 - For estimate: sample many draws from Beta posterior and report mean and 95% credible interval.
 - For simulation mode: given population size N (default 10000), simulate how many in that population wear the item.
*/

// Basic storage (persist in localStorage)
const STORAGE_KEYS = { PRIORS:'ps_priors_v1', EVIDENCE:'ps_evidence_v1' };

function loadPriors(){
  try { return JSON.parse(localStorage.getItem(STORAGE_KEYS.PRIORS) || '{}'); } catch(e){ return {}; }
}
function savePriors(obj){ localStorage.setItem(STORAGE_KEYS.PRIORS, JSON.stringify(obj)); }
function loadEvidence(){ try { return JSON.parse(localStorage.getItem(STORAGE_KEYS.EVIDENCE) || '[]'); } catch(e){ return []; }
}
function saveEvidence(arr){ localStorage.setItem(STORAGE_KEYS.EVIDENCE, JSON.stringify(arr)); }

// Default example priors (explicitly illustrative; replace with sourced data)
const defaultPriors = {
  // keys: "<group>::<item>"
  "male::tank_top_daily": {alpha:12, beta:88, note:"illustrative prior (12%)"},
  "female::tank_top_daily": {alpha:8, beta:92, note:"illustrative prior (8%)"},
  "all::tank_top_daily": {alpha:10, beta:90, note:"illustrative prior (10%)"}
};

function ensurePriors() {
  const p = loadPriors();
  let modified=false;
  for(const k of Object.keys(defaultPriors)){
    if(!p[k]){ p[k]=defaultPriors[k]; modified=true; }
  }
  if(modified) savePriors(p);
  return p;
}

ensurePriors();

/* ---------- Stats helpers ---------- */

// draw one sample from Beta(a,b) using Gamma sampling: X~Gamma(a,1)/(Gamma(a,1)+Gamma(b,1))
function randGamma(shape){
  // Marsaglia and Tsang method for k>0
  if(shape < 1) {
    // boost: sample for shape+1 then scale
    const u = Math.random();
    return randGamma(1+shape) * Math.pow(u, 1/shape);
  }
  const d = shape - 1/3;
  const c = 1 / Math.sqrt(9*d);
  while(true){
    let x, v;
    do { x = normalRandom(); v = 1 + c * x; } while (v <= 0);
    v = v*v*v;
    const u = Math.random();
    if (u < 1 - 0.0331 * x * x * x * x) return d * v;
    if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) return d * v;
  }
}
function normalRandom() {
  // Box-Muller
  let u = 0, v = 0;
  while(u===0) u = Math.random();
  while(v===0) v = Math.random();
  return Math.sqrt(-2.0*Math.log(u))*Math.cos(2.0*Math.PI*v);
}
function betaSample(a,b){
  const ga = randGamma(a);
  const gb = randGamma(b);
  return ga / (ga + gb);
}

// sample array of n draws
function betaSamples(a,b,n){
  const out = new Float64Array(n);
  for(let i=0;i<n;i++) out[i] = betaSample(a,b);
  return out;
}

// compute percentiles
function pctile(arr, p){
  const a = Array.from(arr).sort((x,y)=>x-y);
  const idx = Math.max(0, Math.min(a.length-1, Math.floor((p/100)*(a.length-1))));
  return a[idx];
}

// mean
function mean(arr){ let s=0; for(let v of arr) s+=v; return s/arr.length; }

/* ---------- UI wiring ---------- */

const qEl = document.getElementById('question');
const groupEl = document.getElementById('group');
const behaviorEl = document.getElementById('behavior');
const askBtn = document.getElementById('askBtn');
const addEvidenceBtn = document.getElementById('addEvidenceBtn');
const exportBtn = document.getElementById('exportBtn');

const priorkeyEl = document.getElementById('priorkey');
const priorkeyItemEl = document.getElementById('priorkey_item');
const priorAlphaEl = document.getElementById('priorAlpha');
const priorBetaEl = document.getElementById('priorBeta');
const savePriorBtn = document.getElementById('savePriorBtn');
const priorsListDiv = document.getElementById('priorsList');

const evSourceEl = document.getElementById('evSource');
const evGroupEl = document.getElementById('evGroup');
const evItemEl = document.getElementById('evItem');
const evSuccessEl = document.getElementById('evSuccess');
const evTrialsEl = document.getElementById('evTrials');
const saveEvidenceBtn = document.getElementById('saveEvidenceBtn');
const evidenceListDiv = document.getElementById('evidenceList');

const resultSummary = document.getElementById('resultSummary');
const resultTiles = document.getElementById('resultTiles');
const posteriorOut = document.getElementById('posteriorOut');

function renderPriors(){
  const p = loadPriors();
  priorsListDiv.innerHTML = '<div class="small muted">Saved priors:</div>';
  const ul = document.createElement('div');
  ul.style.marginTop='8px';
  for(const k of Object.keys(p)){
    const d = p[k];
    const row = document.createElement('div');
    row.className='small';
    row.innerHTML = `<strong>${k}</strong>: alpha=${d.alpha}, beta=${d.beta} ${d.note?'<span class="muted">('+d.note+')</span>':''} <button data-k="${k}" style="margin-left:8px">Use</button>`;
    const btn = row.querySelector('button');
    btn.onclick = ()=> { const parts = k.split('::'); priorkeyEl.value=parts[0]||''; priorkeyItemEl.value=parts[1]||''; priorAlphaEl.value=d.alpha; priorBetaEl.value=d.beta; };
    ul.appendChild(row);
  }
  priorsListDiv.appendChild(ul);
}

function renderEvidence(){
  const ev = loadEvidence();
  evidenceListDiv.innerHTML = '<div class="small muted">Saved evidence:</div>';
  const ul = document.createElement('div');
  ul.style.marginTop='8px';
  ev.forEach((e,i)=>{
    const row = document.createElement('div');
    row.className='small';
    row.innerHTML = `<strong>[${i+1}]</strong> ${e.source} • ${e.group} / ${e.item} → ${e.success}/${e.trials} (${((e.success/e.trials)*100).toFixed(2)}%) <button data-i="${i}" style="margin-left:8px">Remove</button>`;
    row.querySelector('button').onclick = ()=>{ ev.splice(i,1); saveEvidence(ev); renderEvidence(); };
    ul.appendChild(row);
  });
  evidenceListDiv.appendChild(ul);
}

renderPriors(); renderEvidence();

/* ---------- Natural language parse (very simple) ---------- */

function parseQuestion(q){
  q = (q||'').toLowerCase();
  // group parse
  let group = null;
  if(q.includes('men') || q.includes('males') || q.includes('male')) group='male';
  else if(q.includes('women') || q.includes('females') || q.includes('female')) group='female';
  else group='all';
  // behavior parse - look for tank top synonyms
  let item = null;
  if(q.includes('tank top') || q.includes('sleeveless') || q.includes('vest top') || q.includes('singlet')) item='tank_top_daily';
  else if(q.includes('hat') || q.includes('cap')) item='hat_daily';
  else item='generic_item_daily';
  return {group, item};
}

/* ---------- Core estimate function ---------- */

function keyFor(group,item){ return `${group}::${item}`; }

function getPriorAlphaBeta(group,item){
  const p = loadPriors();
  const k = keyFor(group,item);
  if(p[k]) return [Number(p[k].alpha)||1, Number(p[k].beta)||1];
  // fallback to 'all::item' then generic
  if(p[`all::${item}`]) return [Number(p[`all::${item}`].alpha)||1, Number(p[`all::${item}`].beta)||1];
  return [1,1]; // vague uniform prior
}

function gatherEvidenceFor(group,item){
  const ev = loadEvidence();
  let succ=0, trials=0;
  const matches=[];
  for(const e of ev){
    if(e.group===group && e.item===item){
      succ += Number(e.success); trials += Number(e.trials); matches.push(e);
    }
  }
  return {succ, trials, matches};
}

function estimatePosterior(group,item, samples=20000){
  const [a0,b0] = getPriorAlphaBeta(group,item);
  const {succ,trials,matches} = gatherEvidenceFor(group,item);
  const aPost = a0 + succ;
  const bPost = b0 + (trials - succ);
  // sample
  const draws = betaSamples(Math.max(0.0001,aPost), Math.max(0.0001,bPost), samples);
  const meanVal = mean(draws);
  const p025 = pctile(draws,2.5);
  const p975 = pctile(draws,97.5);
  return {a0,b0,succ,trials,aPost,bPost,mean:meanVal,ci:[p025,p975],samples:draws,matchedEvidence:matches};
}

/* ---------- UI actions ---------- */

askBtn.onclick = ()=>{
  const q = qEl.value.trim();
  const parsed = parseQuestion(q);
  // allow user override if they typed fields
  const group = (groupEl.value.trim() || parsed.group || 'all');
  const item = (behaviorEl.value.trim() || parsed.item || 'generic_item_daily');
  groupEl.value = group; behaviorEl.value = item;

  const mode = document.getElementById('mode').value;
  const est = estimatePosterior(group,item,12000);

  // render summary
  resultSummary.innerHTML = `<strong>Estimate for:</strong> ${group} • ${item} — posterior mean=${(est.mean*100).toFixed(2)}% • 95% CI ${(est.ci[0]*100).toFixed(2)}%–${(est.ci[1]*100).toFixed(2)}%`;
  resultTiles.innerHTML = '';
  const tileMean = document.createElement('div'); tileMean.className='tile';
  tileMean.innerHTML = `<div class="small">Posterior mean</div><div style="font-size:20px"><strong>${(est.mean*100).toFixed(2)}%</strong></div>`;
  const tileCI = document.createElement('div'); tileCI.className='tile';
  tileCI.innerHTML = `<div class="small">95% credible interval</div><div style="font-size:16px">${(est.ci[0]*100).toFixed(2)}% — ${(est.ci[1]*100).toFixed(2)}%</div>`;
  const tileData = document.createElement('div'); tileData.className='tile';
  tileData.innerHTML = `<div class="small">Prior (α,β)</div><div style="font-size:14px">${est.a0}, ${est.b0}</div><div class="small" style="margin-top:6px">Evidence: ${est.succ}/${est.trials} (from ${est.matchedEvidence.length} sources)</div>`;
  resultTiles.appendChild(tileMean); resultTiles.appendChild(tileCI); resultTiles.appendChild(tileData);

  // posterior sample preview
  const preview = Array.from(est.samples.slice(0,200)).map(x=> (x*100).toFixed(3)+'%');
  posteriorOut.textContent = preview.join(', ');
};

savePriorBtn.onclick = ()=>{
  const group = (priorkeyEl.value||'').trim();
  const item = (priorkeyItemEl.value||'').trim();
  const a = Math.max(0, Number(priorAlphaEl.value||0));
  const b = Math.max(0, Number(priorBetaEl.value||0));
  if(!group || !item || a<=0 || b<=0){ alert('Please fill group, item, and positive alpha/beta'); return; }
  const p = loadPriors();
  p[`${group}::${item}`] = {alpha:a,beta:b,note:'user-saved'};
  savePriors(p); renderPriors();
  alert('Saved prior for '+group+'::'+item);
};

saveEvidenceBtn.onclick = ()=>{
  const src = (evSourceEl.value||'').trim();
  const group = (evGroupEl.value||'').trim();
  const item = (evItemEl.value||'').trim();
  const succ = Number(evSuccessEl.value||0);
  const trials = Number(evTrialsEl.value||0);
  if(!group || !item || trials<=0 || succ<0 || succ>trials){ alert('Fill valid evidence (0 <= successes <= trials, trials>0)'); return; }
  const ev = loadEvidence();
  ev.push({source:src||'user', group, item, success:succ, trials:trials, when:(new Date()).toISOString()});
  saveEvidence(ev); renderEvidence();
  alert('Added evidence');
};

// export results (priors + evidence) as CSV
exportBtn.onclick = ()=>{
  const p = loadPriors(); const ev = loadEvidence();
  let text = 'type,key,alpha,beta,note\n';
  for(const k of Object.keys(p)) text += `prior,${k},${p[k].alpha},${p[k].beta},"${(p[k].note||'')}"\n`;
  text += '\nsource,group,item,success,trials,when\n';
  for(const e of ev) text += `${e.source},${e.group},${e.item},${e.success},${e.trials},${e.when}\n`;
  const blob = new Blob([text], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'simulator_data_export.csv'; document.body.appendChild(a); a.click(); a.remove();
};

// quick "Add evidence" button
addEvidenceBtn.onclick = ()=> {
  // parse current question & prefill
  const parsed = parseQuestion(qEl.value||'');
  evGroupEl.value = parsed.group;
  evItemEl.value = parsed.item;
  // open evidence card by scrolling
  evSourceEl.scrollIntoView({behavior:'smooth'});
};

</script>
</body>
</html>
